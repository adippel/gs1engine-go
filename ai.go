//go:generate go run ./cmd/gs1aigen -out airegistry.go -package gs1 -struct-name "ApplicationIdentifier" -disable-struct-gen
package gs1

import (
	"fmt"
	"strconv"
	"strings"
)

// SymbologyIdentifier as defined in GS1 General Specification v25.0, chapter 5.1.3.
type SymbologyIdentifier struct {
	Type SymbologyType
	Mode int
}

// MessageSyntaxType describes the syntax type when it has been parsed from input, e.g by using [ParseMessage].
type MessageSyntaxType string

const (
	UnknownSyntax          MessageSyntaxType = "Unknown"
	ElementStringSyntax    MessageSyntaxType = "ElementStringSyntax"
	BarcodeMessageFormat   MessageSyntaxType = "BarcodeMessageFormat"
	BarcodeMessageScanData MessageSyntaxType = "BarcodeMessageScanData"
)

// SymbologyType as defined in GS1 General Specification v25.0, chapter 5.1.3.
type SymbologyType string

const (
	UnknownSymbology   SymbologyType = ""
	GS1128             SymbologyType = "C"
	GS1DataBar         SymbologyType = "e"
	GS1Composite       SymbologyType = "e"
	GS1DataMatrix      SymbologyType = "d"
	GS1QRCode          SymbologyType = "Q"
	GS1DotCode         SymbologyType = "J"
	GSDataMatrixECC200 SymbologyType = "d"
)

type ApplicationIdentifier struct {
	// AI is a unique identifier for a class of objects (e.g., trade items) or an instance of an object
	// (e.g., logistic unit).
	AI string
	// Flags indicate specific characteristics about an AI (e.g. pre-defined length).
	Flags string
	// Specification consists of multiple components specify the character set, data format, and
	// data structure required for the AI.
	Specification []string
	// Attributes enable associations of AIs, to ensure mandatory or invalid AI pairs, including primary key and key
	// qualifier sequences for GS1 Digital Link URI syntax
	Attributes []string
	// Title is the data title supporting human understanding of the AI.
	Title string
}

// RequiresFNC1Separator checks if the AI description declares the flag '*'.
func (ai ApplicationIdentifier) RequiresFNC1Separator() bool {
	return !strings.ContainsRune(ai.Flags, '*')
}

func (ai ApplicationIdentifier) HasFixedLength() bool {
	return !ai.RequiresFNC1Separator()
}

func (ai ApplicationIdentifier) Length() int {
	if !ai.HasFixedLength() {
		return -1
	}

	lengthSpec := ai.Specification[0]
	// Remove the leading character class: N,Y,X
	lengthStr := lengthSpec[1:]
	length, err := strconv.Atoi(lengthStr)
	if err != nil {
		return -1
	}

	return length
}

// ElementString is the combination of a GS1 Application Identifier and a GS1 Application Identifier Elements Field. An
// ElementString can be carried by GS1-128, GS1 DataBar Symbology, GS1 Composite, and GS1 DataMatrix and GS1 QR Code
// Symbols.
type ElementString struct {
	ApplicationIdentifier
	DataField string
}

// NewElementString generates an instance of an AI using a description and a data point.
func NewElementString(ai ApplicationIdentifier, data string) ElementString {
	return ElementString{
		ApplicationIdentifier: ai,
		DataField:             data,
	}
}

func (ai ElementString) String() string {
	return fmt.Sprintf("(%s)%s", ai.AI, ai.DataField)
}

// Message describes a GS1 message together with its Symbology, SyntaxType and the Elements describing the message.
// This struct is typically parsed from input, e.g by using [ParseMessage] or one of the more specialized parsers.
type Message struct {
	// Symbology is not encoded in the barcode but is generated by the decoder after decoding and is transmitted as a
	// preamble to the data message.
	Symbology SymbologyIdentifier
	// SyntaxType specifies which syntax is used to encode/decode the message.
	SyntaxType MessageSyntaxType
	// Elements are the AIs describing the message's actual payload.
	Elements []ElementString
}

// AsElementString returns the Message in the element string syntax, e.g. (01)01234567890128(15)057072.
func (d Message) AsElementString() string {
	builder := strings.Builder{}
	for _, datum := range d.Elements {
		builder.WriteString("(")
		builder.WriteString(datum.AI)
		builder.WriteString(")")
		builder.WriteString(datum.DataField)
	}
	return builder.String()
}
