//go:generate go run ./cmd/gs1aigen -out airegistry.go -package gs1
package gs1

import (
	"bufio"
	"bytes"
	"fmt"
	"html/template"
	"io"
	"net/http"
	"slices"
	"strconv"
	"strings"
)

const tmpl = `// DO NOT EDIT.
// Code generated by github.com/adippel/go-gs1engine/genairegistry. 

package {{ .PackageName }}

// AIDescription describes a GS1 Application Identifier (AI) as defined in the GS1 Syntax Dictionary.
type AIDescription struct {
	// AI is a unique identifier for a class of objects (e.g., trade items) or an instance of an object 
	// (e.g., logistic unit).
	AI	string
	// Flags indicate specific characteristics about an AI (e.g. pre-defined length).
	Flags string
	// Specification consists of multiple components specify the character set, data format, and
	// data structure required for the AI.
	Specification []string
	// Attributes enable associations of AIs, to ensure mandatory or invalid AI pairs, including primary key and key
	// qualifier sequences for GS1 Digital Link URI syntax
	Attributes []string
	// Title is the data title supporting human understanding of the AI.
	Title string
}

// Go descriptions for the GS1 Application Identifier. Enable seamless parsing and validation of GS1 messages.
var (
{{- range .AIs }}
	// AI{{ .AI }} describes a {{ .Title }}. See also https://ref.gs1.org/ai/{{ .AI }}.
	AI{{ .AI }} = AIDescription{
		AI:				"{{ .AI }}",
		Flags:         	"{{ .Flags }}",
		Specification: 	[]string{ {{- range .Specification -}} "{{- . -}}", {{- end -}} },
		Attributes:    	[]string{ {{- range .Attributes -}} "{{- . -}}", {{- end -}} },
		Title:         	"{{ .Title }}",
	}
{{- end }}
)

// AIRegistry is a lookup table mapping a GS1 AI to its corresponding [AIDescription].
var AIRegistry = map[string]AIDescription{
{{- range .AIs }}
	"{{ .AI }}": AI{{ .AI }},
{{- end }}
}
`

// GenOpts describe available options for using [GenerateAIRegistry].
type GenOpts struct {
	PackageName string
}

type aiSpec struct {
	AI            string
	Flags         string
	Specification []string
	Attributes    []string
	Title         string
}

// DownloadSyntaxDictionary downloads the most recent GS1 Syntax Dictionary from
// https://github.com/gs1/gs1-syntax-dictionary/blob/main/gs1-syntax-dictionary.txt. Pass a tag to release to download
// the correct dictionary.
func DownloadSyntaxDictionary(release string) (bytes.Buffer, error) {
	url := fmt.Sprintf("https://raw.githubusercontent.com/gs1/gs1-syntax-dictionary/refs/tags/%s/gs1-syntax-dictionary.txt", release)
	resp, err := http.Get(url)
	if err != nil {
		return bytes.Buffer{}, fmt.Errorf("error downloading syntax dictionary release %s: %w", release, err)
	}
	defer resp.Body.Close()

	data := bytes.Buffer{}

	_, err = io.Copy(&data, resp.Body)
	if err != nil {
		return bytes.Buffer{}, fmt.Errorf("error reading syntax dictionary release %s: %w", release, err)
	}

	return data, nil
}

// ParseSyntaxDictionary reads in the format of the GS1 Syntax Dictionary published here
// https://github.com/gs1/gs1-syntax-dictionary. Returns
func ParseSyntaxDictionary(r io.Reader) ([]aiSpec, error) {
	var entries []aiSpec
	scanner := bufio.NewScanner(r)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue // skip comments or blank lines
		}

		// Find the title by splitting on " #"
		var title string
		titleSplit := strings.SplitN(line, " #", 2)
		if len(titleSplit) == 2 {
			title = strings.TrimSpace(titleSplit[1])
			line = strings.TrimSpace(titleSplit[0])
		}

		fields := strings.Fields(line)
		entry := aiSpec{
			Title: title,
		}

		for i, field := range fields {
			if slices.Contains([]rune("0123456789"), rune(field[0])) {
				entry.AI = field
			} else if slices.Contains([]rune("*!?\"$%&'()+,-./:;<=>@[\\]^_`{|}~"), rune(field[0])) {
				entry.Flags = field
			} else if slices.Contains([]rune("NXY"), rune(field[0])) {
				entry.Specification = strings.Split(fields[i], ",")
			} else {
				entry.Attributes = append(entry.Attributes, field)
			}
		}

		// That's a specification spanning several AIs
		if strings.Contains(entry.AI, "-") {
			aiRange := strings.Split(entry.AI, "-")
			startAI, err := strconv.Atoi(aiRange[0])
			if err != nil {
				return nil, fmt.Errorf("error parsing start AI range %s: %w", entry.AI, err)
			}
			stopAI, err := strconv.Atoi(aiRange[1])
			if err != nil {
				return nil, fmt.Errorf("error parsing stop AI range %s: %w", entry.AI, err)
			}

			for i := startAI; i <= stopAI; i++ {
				strconvAI := strconv.Itoa(i)
				entries = append(entries, aiSpec{
					AI:            strconvAI,
					Flags:         entry.Flags,
					Specification: entry.Specification,
					Attributes:    entry.Attributes,
					Title:         entry.Title,
				})
			}
		} else {
			entries = append(entries, entry)
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return entries, nil
}

// GenerateAIRegistry generates [AIDescription] and a lookup table from the given ais.
func GenerateAIRegistry(out io.Writer, ais []aiSpec, opts GenOpts) error {
	tplOpts := struct {
		PackageName string
		AIs         []aiSpec
	}{
		PackageName: opts.PackageName,
		AIs:         ais,
	}

	t := template.Must(template.New("ai").Parse(tmpl))
	err := t.Execute(out, tplOpts)
	if err != nil {
		return fmt.Errorf("error executing template: %w", err)
	}
	return nil
}
